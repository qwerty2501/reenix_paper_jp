[ここ](http://scialex.github.io/reenix.pdf)の翻訳になります
# Reenix: **Rust**でのUnixライクオペレーティングシステムの実装

Alex Light(alexander_light@brown.edu)  
Advisor: Tom Doeppner  
Reader: Shriram Krishnamurthi  
Brown University, Department of Computer Science  

## <div style="text-align: center;">主題</div>
  
  この論文はRustでのUnixライクなOSカーネルの実装でわかった成功と失敗の体験を説明するものである。  
  CS167/9のために書かれたWeenix OSの基礎デザインと大量の低レベルな処理をサポートするコードを使って、協調的にスケジュールされた複数のカーネルプロセスをサポートする基本的なカーネル、基本的なデバイスのドライバーと仮想ファイルシステムの端緒を作ることができた。  
  Rust言語とその方安全システムで助けになったことといくつかの妨げ、このカーネルのRustとCの実装とのパフォーマンス比較について書き残しておく。  
  また、Rust言語とWeenixプロジェクトの概要も含める。  

## <div style="text-align: center;">概要</div>

1971年に最初に作られて以来UNIX OSはソフトウェア開発に定着した。世界のOS開発と一般的なソフトェア開発への貢献の一つはそれを書くために作られたC言語だ。リリースされてから数十年、Cは相対的に小さくしかし最先端のプログラミング言語設計とチェックを変えられ、大きく進歩した。unixのほぼすべてのOSカーネルがCまたはC++のような言語で書かれていたという成功に感謝する。これはC以降の言語設計の進歩がさらに表現豊かで検証可能な領域の大部分が成功することを意味している。  
このプロジェクトのゴールはRustを用いてunixライクなOSを作るのを試みることにある。私の知る限りでは、これは本気で試みられたことはないか、現在までに誰も成果を上げていないプロジェクトだ。これにより実現可能性とRustのような高水準言語でカーネルを作ることの利便性を見出すことができた。同様に目的に合わせて言語の改善点を見つけることができる。  
さらにＣ以外の言語を通して調べたunixの基礎デザインがどれだけ保持しているか評価することが認められることになるだろう。最後に、私たちは完成されたカーネル検証のタスクを扱ったRustの洗練された型安全なシステムをさらに体験することになるだろう。カーネル高速化のさらに高水準なパーツをやりはじめるのを認めてもらうために、私はCS169で実装されたWeenix OSでの成果をベースにした。これでOS開発に特化したものではない、メモリアロケートといったたくさんの低レベルのカーネル部分を実装しなくてよくなった。  


## 1.1 Weenix OS  
  
Weenix OSはx86ベースの教育用OSとして1998年にブラウンのCS167 OSコースで作られた。  
現在CS169選択コースの学生たちはCS167に多くのWeenixによるunix-like OS由来の高レベルな部分で実装している。  
学生たちはOSブートと実行のCコードを取得するために必要なコード、及びメモリ管理、デバッグプリントシステム、そして基礎的なlibc実装をこのプロジェクトで開始している。これを元にCS169の学生たちはかなり完成されたunix OSの実装を続けている。  プロジェクトと、それをサポートするコードはほとんどがCで、pythonとシェルスクリプトをOSの実行とテストのために書いた。  
このプロジェクトは複数に分割されていて、いわゆるプロセス、ドライバー、VFS、S5FS、そしてVMからなる。プロセスはUnixライクなプロセスモデルな親子関係プロセスと初期化プロセスをシンプルなスケジューラと原始的な同期により実装されている。ドライバはTTYドライバ、ユーザ入力とハードディスクを使用する(最低限の)ATA相互接続ドライバに大きく分割してされている。VFSは、抽象型仮想ファイルシステムで、テストのためにRamFSと呼ばれるram-backedファイルシステムの提供を採用している。S5FSはS5ファイルシステムと呼ばれているsysv-fsファイルシステムのバージョンの一つで、非揮発性ストレージを提供するために実装されている。最後にVMは仮想メモリとユーザースペースにより実装されている。これらはまた多くの最終OSがテストできるユーザースペースを提供してきた。  
  
## 1.2 Rust言語  
  
[Rust](http://www.rust-lang.org)言語は相対的に新しいシステムプログラミング言語で、Mozilla Foundationにより作られている。Rustは一般的に小さく高いパフォーマンスの低レベル層や組み込みプログラミング環境としてのCを使いやすく置き換えるために設計された。Mozilla FoundationはRustを使用してRustコンパイラ(Rustc)やServoと呼ばれる実験的なウェブブラウザといったいくつかの公式プロジェクトにRustを使用している。それはまた、Mozillaの有名なFirefoxブラウザをRust実装し始めることを近い将来に計画している。Rustは現在[Github](https://github.com/rust-lang/rust)上で開発いる。プロジェクトは非常に人気で開かれており、千人のコントリビュータがいますがそのほとんどはMozillaと関係がない。  
Rust自身は手続き指向型プログラミング言語でCのようなシンタックスになっている。それは包括的な型システムや、データ"ライフタイム"システムとメモリ確保のための小さなランタイムとコンパイル時のスレッド安全性を採用している。具体的にRustはデータが他のオブジェクトによって使用されたときに予想外の変更されないことを保障するために所有権とライフタイム追跡システムを使用している。加えて、ライフタイム追跡システムはdanglingポインタができない言語を保障するために使用している。Rustのランタイムは分離可能なたくさんのパーツで構成されている。それはシンプルなアウトオブメモリもしくは致命的なエラーを回復する、求められた(そして最も基礎的な)機能だ。その最たる例の内にReenixが含まれていて、ヒープメモリの確保のためのインターフェースを提供する。ランタイムの他のすべての機能はOSの実行、ディスク入出力、プロセス間通信そしてスレッド作成、そのたもろもろを一貫性のあるインターフェースとして提供するためにある。

## 1.2.1 シンタックスとセマンティクス  
  
Rustのシンタックスも同様だが、ほかのCライクなプログラミング言語とは少し違う。言語機能を説明するために図を使用して説明しよう図1にはRustでの基礎的なクイックソート実装が含まれている。Rustのシンタックスとセマンティクスのすべての詳細はオンライン上の[doc.rust-lang.org](http://doc.rust-lang.org/reference.html)で見つけることができる。  
最も顕著な違いはRustには式と文にいくつかの違いがみられるということだ。Rustの式ではいくつかのコード片がyieldな値であることだ。文について、ほかの手によって値が作られることはない。  
  
```rust
/// 基本的なクイックソート実装  
/// 型ジェネリッククイックソート。 ‘T‘はソート対象の型で全体を順序付けなければならない。
/// (‘Ord‘ traitを実装すること) listで渡され、要素をソートしたソート済みlistを返す。 
/// この過程のlistはmutableで変更可能であると言える。  
pub fn quicksort <T: Ord>(mut lst: Vec<T>) -> Vec<T> {   
    // ピボットから要素を取り出し、listが空なら何も返さない(そしてelse句へ行く)。   
    // そうでなければlistから最初の要素を取り除き、返す。  
    if let Some(pivot) = lst.pop() {   
        // ピボット周辺のlistを分ける。listを反復する(into_iter function)そして二つのlistに分ける。   
        // パーティション関数は二つのlistを返す。1番目のlistは全ての要素が状態がすべてtrueのもの、2番目の　　
        // listは全てfalseのものである。     
        let (less, more): (Vec<_>, Vec<_>) = lst.into_iter().partition(|x| x < &pivot); 　　
        // ピボットより小さいlistの半分を再帰的にソートする。これはいずれ返されるlistとなる。  
        let mut res = quicksort(less);   
        // ソート済みのlistの半分の小さい方の最後の要素をピボットにする。これは'res'listにピボットを追加することである。
        res.push(pivot);   
        // 半分に分けた大きい方のlistをソートし、ソート済みの小さい方のlistとピボットに追加する。     
        // extendは'res'listに 与えられたlistの全てを追加する。
        res.extend(quicksort(more));   
        // 現在のソート済みlistを返す。ここではreturnが必要ないことを注意すること。   
        // 単純にこの行は'res'と書くだけでいい (’;’が必要なことは注意する)   
        // 関数が最後の式の値を返すのは(このif-elseのように)分岐の最後の値(Vec<T>)を取ることと同等だろう。
        return res;   
        } else {   
        // lst.pop()により、listが返されなかった場合emptyでなくてはならないのでempty list をここに記述する。
        // returnは必要ではなくこれはブロック内の最後の式とこのブロックがfunction内で最後の式であることを注意すること。   
        // vec!は標準的なマクロで、Vec<T>を作成する。   
        vec![]   
    }   
 }
  
   
 fn main() {   
    // ソートするlistを作成する。vec!はマクロでリストされた要素のvecを作成する。     
    let lst = vec![3,1,5,9,2,8,4,2,0,3,12,4,9,0,11];   
    println!("unsorted: {:?}", lst);   
    // quicksortを呼び出す。これはlstの所有権を放棄する。   
    println!("sorted: {:?}", quicksort(lst));   
 }
```

## <div style="text-align: center;">**図1**:Rustでのquick sort</div>  
  
```rust
/// トレイト。構造体と列挙体はこれを実装できる。   
pub trait Id {   
  /// 要求される関数。 全ての実装するものはこの関数について定義を提供しなければならない。でなければ型チェックで失敗する。  
  /// ’staticは文字列が静的に確保されていることを要求されているという意味だ。  
  fn username(&self) -> &’static str;   
  /// 既定実装付きの関数。返される文字列は少なくともIdが有効な間使用可能でなくてはならない。  
  /// ’aは返されるstrが少なくとも’self’が使える間使えなくてはならないということを意味する。  
  /// 型チェックはこれが真であることを保障する。
  fn screenname <’a>(&’a self, _board: &str) -> &’a str { self.username() }   
}

  
/// 構造体。 deriveは与えられたトレイトの規定実装を提供する。   
/// トレイトはこの方法でのみ実装されるだろう。    
#[derive(Debug, Eq, PartialEq)]   
pub struct Account { name: &’static str, msgs: Vec<u64>, }

  
// Id taritの実装。 
//既定の実装では’screenname ’が実装する必要ではないことを注意すること。
impl Id for Account {   
    fn username(&self) -> &’static str { self.name }   
}

  
// Accountに関連する関数を直接実装  
impl Account {   
  pub fn get_messages(&self) -> &[u64] { &self.msgs[..] }   
}

  
#[derive(Debug, Eq, PartialEq)]   
pub enum Commenter {   
  /// データ付き列挙体の値 
  User(Account),   
  /// データなしの列挙体の値  
  Anon,   
}

  
/// Idトレイトの実装   
impl Id for Commenter {   
  fn username(&self) -> &’static str {   
    // 値別のアクションを選択する。  
    match *self {   
      Commenter::User(ref a) => a.username(),   
      Commenter::Anon => "Anon",   
    }   
  }   
}
```  
  
## <div style="text-align: center;">**図2**:Rustのtraitとtype</div>  
  
全ての関数内の一般的な式は場合を(1)let変数を除いて変更可能で、図1の14,17行目と40行目のような(2)ループ構造と(3)式または文のあとにセミコロンが置かれる。カーリー括弧に分割されたブロック({})は最後の式の値を使える式であることに注意してほしい。if-elseやmatchブロックは同じような式だ。例として図1でのif-elseブロックは9行目から開始されているVec<T>型の式だ。Rustはブロックで開始し、関数内の最上位の最後の式の値を暗黙的にreturnされている式にすることを採用した(図1内の9行目から開始されるif-elseだ)。が、図1のうちの一つは未だに’return <value>;’の形式をとっている。これは図2の45-47行目のようにmatchの戻り値が関数である場合にも見て取れる。さらに、これは図1の23行目を単純に’res’とプログラムを同じ意味で変えることを意味している。  
  
