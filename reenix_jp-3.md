<style type="text/css">
li.L0, li.L1, li.L2, li.L3, li.L4, li.L5, li.L6, li.L7, li.L8, li.L9
{
    list-style-type: decimal;
}
</style>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?autoload=true&amp;skin=desert&amp;lang=rust" defer="defer"></script>
[ここ](http://scialex.github.io/reenix.pdf)の翻訳になります  
原文は2015年に書かれたものなので現在のRustの仕様と異なることが書いてある場合があります  
本文章は[Github](https://github.com/qwerty2501/reenix_paper_jp)で管理されています    
  
# 3 Rustの評価  
  
小節1.2で言及した通り、Rustはかなり新しく、メモリと型安全に注目したシステム指向型プログラミング言語である。Rustのより包括的な型とメモリ分析は、ますます速度と安全性の両方を求められるようになった状況に置かれているCの素晴らしい代替にするためにある。以前はRustでOS作成など誰も真剣に試みたことはなかったし、Reenix実装を通して私はこの界隈でのRustの強みと弱みの深い認識を得ることができた。また、私は様々な分野においてRustが変更されてこの領域での利便性が向上するのを体験することができた。  
ここではRustを使うことによる利点とプロジェクト全体を通して発見したことについて解説する。次に、Rust使用上の問題について検証し、現在起こっている言語上の主要な問題について見ていく。最後に、RustのパフォーマンスをCと比較して短い検証をして終える。  
  
## 3.1 Rustの利点  
  
このプロジェクトの過程で、私はシステムプログラミングにおいてRustを使うことは、CまたはC++を超える沢山の利点があることを見つけた。これらを並べると、利便性における問題が簡単であること、可用性における主要な進歩の明快であること、正確なコード作成のための機能からなる。  
  
### 3.1.1 高水準言語  
  
最も明確である、OS開発(もちろん一般的な開発も)において、Cのような言語を超えるRustを使用することの利点は、C++、Java、Python、そして他の言語から多くの期待した高水準言語プログラマで構成されることが事実であるということだ。Rustはオブジェクトに付けられているメソッド、データとメソッドの明確な関係の許可、(健全な)演算子オーバーロード、そして単一の名前空間で機能を纏めてグループに関連さることを許可するモジュールシステムなどといった標準的なプログラミング抽象化を提供する。これら全ては、遥かに強く関連付けられた部品間の概念的な繋がりの作成による冗長さと曖昧さをより少なくすることができる。  
糖衣構文より、Rustの簡単で便利な実装の更なる高水準な特質はまた、どのように我々がこの言語を使うかという主要な効果をもつ。トレイトを通すことにより、Rustはインターフェースの利用による仮想メソッドテーブル(vtable)の作成と自動的な仕様をより簡単に提供する。これはまた、C関数のような仮想メソッドの定義を書く必要性があるものよりも難解さを少なくしたキャストを実行する。さらに優れているのが、Rustは使用される前に正確な型を知っていることを証明できる場合、vtableを省略してコードをコンパイルするのために十分賢いということだ。これにより、通常のCでできることよりも、多くの一般的なシステム作成と、前よりもより多くのインターフェースの利用を簡単にすることができる。Rustは自動的にスコープ内でオブジェクトを破棄するセマンティクスを持つ上、破棄されたオブジェクトの型を基底とするカスタムデストラクタをサポートする。これでできるリソース取得の利用は初期化(RAII)セマンティクスとなる。我々は例えば、関連付けられたMutexのロックなしで同期されたデータへのアクセス、またはデータの保護が終わった場合に解放しないMutexといった、今までにないことを確実にするためにこれを使用することができる。さらにこれは常に正確なカウントを保障する参照カウントポインタ作成のために使われることができる。これは、関数が失敗するときに単純にエラーを返すことができるので、多くの関数での失敗のハンドリングを大幅に簡素化し、Rustのコンパイラは全ての初期化されたオブジェクトのデストラクタが正確に実行されるのを確実にする。  
最後に、Rustは可能ならデータ量が大きなコピーを避けるため、関数のシグネチャを少しばかり自動的に書き直す。これはRustがしばしば戻り値に外部ポインタの代わりに巨大なオブジェクトを返す関数のシグネチャを書き換えることを意味する。返されたオブジェクトの配置を定義することを呼び出したものに認めることにより、例えばmoveでヒープ上から返されたオブジェクトのような、メモリコピーを防ぐ。rustcがRustソースコードの可読性を向上させるこの書き換えと、実関数が行うことの曖昧さを減少させる。  
例えば、図5で見れるstat関数と図9で見れるそのCバージョンの比較をしよう。両関数はセマンティクスとして'stat'構造体またはエラーを返す。しかしながら、Cではコストのかかるメモリコピー操作を回避するために'stat'構造体を外部ポインタとして取るためにシグネチャを変更する必要がある。しかも、この曖昧さは少しばかり関数の監視を要する。だがRustの場合、この関数は'Stat'またはエラーを返すというこの型シグネチャの本来のセマンティクスを持つ。この関数をコンパイルする時のRustコンパイラは、同様にコストの高いコピー操作を避けるために、シグネチャをCのそれと一致するように変更する。同じことをするのにCのコードと同じことをするのに、速さでは匹敵するが、セマンティクスはよりきれいになることを意味する。  
  
<pre  class="prettyprint linenums: lang-c" >typedef struct vnode_ops {
    // ...
    int (* stat )( struct vnode * vnode ,
    struct stat * buf );
    // ...
} vnode_ops_t ;</pre>  
  
### 3.1.2 型及びライフタイムと借用チェッカー  
  
他の主要なRustを使うことでOS開発者を招く利点として包括的な型、ライフタイム、借用チェックシステムがある。これら三つの道具とともに、コード上のエラークラスを完全に除去する手助けを行う。これらのシステムはCで可能な方法よりもよりリッチなコードの意味を表すことを認める。  
Rust言語が型安全で手続き指向的であることは小節1.2で述べた。標準ライブラリが提供するいくつかのラッパー型は型安全なコードを正しく書くのを手助けする。これらラッパー型の最も重要なものは二つあり、一つは **Result&lt;R,E&gt;** 型で、成功した場合は操作の(型Rの)値を返し、失敗した場合(型Eの)値を示すものと、もう一つは **Option&lt;T&gt;** 型で、T型の値またはその型の値がないことを示す **None** からなる。操作が失敗する可能性があるか、値が提供されない可能性を示すために使用される。これらの型はRustのコードの全ての場合で使用され、インターフェース内に通知可能性があることは事実で、上記で見れる(図4、図5、図6を見よ)最も関数が返すKResultオブジェクトは **Resultシンプルなエイリアスだ。これらの型の使用を通して、コメントによる説明なしで正確な戻り値の意味をさらに具体的に伝達することができる。さらには、型システムがCでは一般的な、このような関数のふるまいによって多くの失敗が起きてしまうのを防ぐ。Rustでは明示的にハンドルされなければならないエラーが発生してないことを確認することなしで、結果オブジェクトを返す関数の結果にアクセスすることが可能である。これは例えば、ほぼ完全に明確に、図5でのstat関数のセマンティクスを作り、型システムによってチェックされるが、一方図9におけるCのそれは同様のセマンティクスを持っているのにもかかわらず、より少ない明示と全てにおいてチェックされない。  
型チェッカーに加えて、借用チェッカーとライフタイムシステムもまた多くのエラーの一般的な型を防ぐことを、幾分コードをきれいにすることで助ける。ライフタイムシステムは全ポインタ参照が安全で、かつ未初期化のものや可能ではあるが解放済みのデータを参照しないことを要求する。時々この証明が得るためには、違う型とそれらのライフタイムの相互関係を明確にするアノテーションを与える。加えて、それはまた、オブジェクトのポインタが解放された後、保持されるポインタがないことを明確にする。それらとともに、ほぼすべての"解放後の使用"バグと"未初期化データ"バグ発生を防ぐ。加えて、ライフタイムシステムはどの程度の間相違する型の間でポインタを保有している時に有効かを重んじることに依存する型シグネチャを正確に指定することを強要する。最後に、借用チェッカーはデータ構造体間の依存を確認するためにライフタイムシステムを使用することで、同時に変更することを防ぐ。これにより他のコードによって、コードが無効なポインタを保持するバグを防ぐ。  
  
### 3.1.3 マクロとプラグイン  
 
他のRustを使うことでCより優れている利点はRustは包括的で力強いマクロとプラグインシステムを有しているということだ。小節1.2.1で述べたように、Rustのマクロは衛生的なRust構文抽象化ツリー(AST)の変換である。