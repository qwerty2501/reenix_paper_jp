<style type="text/css">
li.L0, li.L1, li.L2, li.L3, li.L4, li.L5, li.L6, li.L7, li.L8, li.L9
{
    list-style-type: decimal;
}
</style>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?autoload=true&amp;skin=desert&amp;lang=rust" defer="defer"></script>
[ここ](http://scialex.github.io/reenix.pdf)の翻訳になります  
  
## 2 Reenix  
  
ReenixはRustで可能な部分のWeenix OSの大部分の再実装するという筆者のプロジェクトの名前だ。このプロジェクトでは仕事をWeenixプロジェクトでほとんど行ったように分けた。Weenixの5つのセクションで(小節1.1を見てほしい)、十分に1番目と2番目、プロセスとドライバを実装できた。また、VFSの非自明な部分のプロジェクトとS5FSとVMを完成させるために必要なコード作成を終えることができた。これを行う上でまた、Weenixの大部分をRustのコードをサポートするために変換と書き直しをする必要があった。プロジェクトの結果を含んだ全てのコードとオリジナルのWeenixへのパッチは[Github](https://github.com/scialex/reenix)で見つけることができる。  
  
# 2.1 機構  
  
Reenix立ち上げにおいて、Rust言語のcrateのコンセプトを使った。Rustのcrateは関連するライブラリにコンパイルされることができるコードのパッケージ、または(いくつかのケースにおいて)バイナリだ。それらは一般的に'lib.rs'ファイルがあるフォルダを見つけることにより識別され、crateルートのための標準の(必須ではない)名前となる。Reenixのためプロジェクトを完全に新規の9つのプロジェクトに分けた。それらはまた、このプロジェクトで使っていた三つのコンパイルプラグインで、内二つは筆者が作成した。最後に、いくつかの標準ライブラリの枠組を利用し、Reenixのためだけに使う標準ライブラリのバージョンを作った。  
相対的にReenixは19のcrateと完全にカスタムした12のものを利用する。  
Reenixのcrateの大部分がWeenixプロジェクトの機構をミラーしている。メモリマネージメントアーキテクチャはmm crateを含んでおり、プロセス関連コードはprocs crateなどがある。しかしながらそれらはいくつかのcrateはWeenixの本当の類似物ではなく、Reenixに存在する。最初は、それらのうち最も基本的な基礎crateだ。このcrateは大きくそしてやや異なった型とトレイトのコレクションを持っている。これはcrate作成を可能にするためさらに下の依存ツリーの他のcrateのいくつかを部分的に知ることだ。このcrateにトレイト宣言があることで全てのcrateでトレイトが実装されている場合の依存で使われることができた。このcrateの別の機能はReenixでerrorsとして使われている基礎データ型の大部分を持っている。また'dbg'マクロを難なく使われることができるようにこのcrateに配置した。他の新しいcrateは(幾分悪い名前ではあるが)startup crateという。このcrateは最もCコード関数実装へ関連づけるためのACPI,PCIそしてGDTへのstubを最も保持しており、ブートされている間最も使われるためそう名づけられた。これらは、実際のハードウェアと複雑なbit-twiddling実行管理を要求する能力とメモリマニピュレーション、Rustでできる最善なことのいくつかなどがとても緊密に関連付けられている。また、データ関数のスレッド仕様の実装に含める。これらは主にここに置かれ、Reenixスレッドが作ったRustのスタックオーバーフロー検知実装をとても簡単にするという事実により全て作成した。最後の総合的に新しいcrateはumem crateだ。このcrateは完全に終わっておらず、そして現在いくつかのユーザスペース仮想メモリとページフレームキャッシュ実装を実装するためのメカニズムの必要性を持っている。Weenixではこれらはいくつかのmm階層になっているが、Rustでそれをするには、保持するcrateとRustの標準ライブラリの利用だけではより難しい。  
  
# 2.2 ブート  
  
一つ目の挑戦として、Reenixを手に入れるためにシステムブートを書いていた。Weenixは(私が開始した時点では)カスタム16bitアセンブリコードのブートローダを利用していた。  
このブートローダは残念なことに4MBより大きなカーネルイメージを読み込むことができなかった。これは判明してすぐに問題になった。簡潔な出力を作成することをするのにrustcはgccよりも熟達していない。事実、この問題に直面しはじめたころからrustコードでの作業をやめる前は、かろうじて"Hello World"を作ることができた。  
この問題の修正は多くの早期のすべてx86アセンブリなブートコードの修正を要求した。また、Linuxのブートローダで有名なGRUBを使っていたブートディスク作成のためのビルドシステムの一部書き直しと、マルチブートをサポートするためのブートシーケンス仕様の変更を要求した。それ自体がひどく難しいというわけではないが、これはいくつかのシンプルなハックでCだと可能でRustだとできないこのプロジェクトを公開する試みのソートするために、絶対に必要なことだった。CはWeenixのような4MB以下の適度に複雑なカーネルを維持するのに完全に実現可能で、CS169の歴史でこの制限で実行するものはほぼ誰もいなかったのは事実だ。しかしながらRustにおいてこの制限はほぼすぐに知らしめられた。これはもっとRustコンパイラ最適化(またはその欠如)が言語自身で行っていることよりも多くのことを行っているようで、何人かのソフトウェア開発者の間で最適化の問題があることは事実だ。より確立された言語と比較した場合のRustの相対的な不足を考察する必要がある。  
  
# 2.3 メモリと初期化  
  
他の初期の試みとして、メモリアロケート作業に直面していた。たくさんの理由により、気持ちとしてはむしろこのプロジェクトの範囲外でいたので、Rustでメモリアロケータ実装をせずに、代わりにWeenixに存在するアロケータを使うことにした。これはSlabアロケータというWeenixのアロケータから小規模な問題を引き継いでおり、連続したFixedサイズなデータ構造体のSlabメモリだ。これらのアロケータの型は実際非常に使いやすく、カーネルタスクと使用されたFreeBSDとLinuxのような現実のカーネルに使われた。それらはまた、一般的にオブジェクトキャッシュスキームを含んでいるが、Weenixはそのようなスキームを使用していなかった。それらは一般的に多くのOSにて素早くアロケートされるために、サイズが知られている少数の構造体からなる。  
問題となっているのはRustがmallocスタイルなメモリアロケータのアイディアでビルドされていることだ。この手のアロケータはどんなサイズでもバッファをアロケートできなければならないmallocからなるslabアロケータを使用して実装するのは逆に大変だ。一つの要求として、いくつかのシステムで、malloc関数はたくさんの違うサイズのslabアロケータから適切なアロケータを探し出す必要がある。slabアロケータを簡単に使用するのを認めるためカスタムアロケータサポートをRustに追加に関していくつかの議論があるが、これはRust1.0では盛り込まれず、延期された。さらに、言語とコンパイラはまた、いくつものセンスによるアロケーションのアイディアから成り立っているのは間違いない。OSカーネルにおいて、これは平常を保つことができない。これはRustコンパイラがこれらの課程を組み込むことは残念なことにかなり深い問題だ。この問題の詳細を小節3.3にて解説する。これをサポートするためにWeenixアロケータがそうであるように、かなり複雑なshim周りをサポートするRustアロケータモデルを最終的に書く必要があった。結局全ての基地のアロケータは常にメモリが確保された状態かつ、有効なメモリを選択するコードを書くことになった。しかしこれはアロケータがカスタムタイプ向けに完全にサイズ計算されたものありつづけるためと、利用するのに良いスペースを確保するという二つの利便性の点で問題を作った。しかしこれを行うには一般的に使われる全てのアロケータのリストを取得する必要があった。これは幾分奇妙なブートのためのマルチステージ初期化案を作ることを要求した。アロケートがまだセットアップされていない場合の初期化を最初のステージとした。このフェーズの間、各部はアロケータに予約するかほかのセットアップに関連付けられたアロケートを要求しないタスクが含むCのプロジェクトの初期化パーツが行うのを要求する。これはWeenixからのtapdance初期化の他の二つのフェーズに追加される。一度これは我々が全ての他のリアルスレッドコンテキストに実行可能な初期化をされ、アイドルプロセスに入った時に最後の初期化を行う。  
  
# 2.4 プロセス  
  
この小節ではどのようにプロセスが作られ、管理と停止をカバーするプロセスシステムのもっとも基礎的な関数２つについて解説する。次に、内部スレッドの同期が実行と維持されることについて解説する。最後に、Reenixスケジューラの調査とどのように作成と振舞いを行うかについて説明する。最初のReenixの主要な部分である包括的なプロセスコントロール、スケジューリングと同期はまた、CS169 WeenixプロジェクトのPROCSで実装される。Weenix基礎設計に従って、プロセス構造を選択した。実行中のスレッドの各プロセスのヒエラルキーがある場合に、プロセスとスレッドは分割される。スレッドとプロセスは分けてかたどられ、プロセスは少なくとも最低一つのスレッドを持つ。標準的なUnixでは、プロセス内に親子関係の追跡とプロセス初期化時にはぐれたプロセスを退避させる。プロセスは子プロセス情報とメモリマップを保持する。  
  
<pre  class="prettyprint linenums: lang-rust" >pub struct KProc {
  /// プロセスID
  pid : ProcId ,
  /// プロセス名
  command : String ,
  /// スレッド
  threads : HashMap <u64 , Box < KThread > > ,
  /// 子プロセス
  children : HashMap < ProcId ,
    Rc < ProcRefCell < KProc > > > ,
  /// 有効かどうかのステータス
  status : ProcStatus ,
  /// 実行中/スリープ中/他
  state : ProcState ,
  /// 親
  parent : Option < Weak < ProcRefCell < KProc > > > ,
  /// ページディレクトリ
  pagedir : PageDir ,

  /// wait - waitpidのキュー
  wait : WQueue ,
 }</pre>  
   
**図3:** Reenixでのプロセス構造体はWeenixのそれととてもよく似ているが、子プロセスやスレッドを保持する目的でWeenixの拘束リストの代わりにハッシュマップを利用している。  
  
図3で見て取れるように、プロセス構造体の定義に少し注釈をいれた。もしそれを実装から離れたところにしたのなら、プロセスはまた、開かれたファイルとすべてのスレッドで共有されるカレントディレクトリ情報を保持している。スレッドはプロセスが現在何をしているかの情報を保持し、スケジューラの作業とともに、スタックの保有とブロックを行う。  
  
# 2.4.1 コントロールと作成  
  
Reenixは非常にシンプルなプロセスコントロールモデルを保有する。KProc::new関数によってプロセスをいつでも作成することができ、その第一スレッドによって呼び出される。この関数は新しいプロセスのユニークID番号か、なにか良くないことが起こった場合、エラー識別値を返す。一度この関数が呼ばれると、作成されたプロセスはスレッドが終了するかメイジ的に止められるまで実行し続ける。現在Reenixではマルチスレッドプロセスをサポートされていない。スレッドはプロセスの作成によって作られるためだ。この制限は現在における利便性のためにある。プロセスのデザインとスレッドは切り替えられるよう許可することは、マルチスレッドプロセスよりも簡単だ。Reenixに**kill(2)**に類似した機能はなく、スレッドを強制的に終了することはできず、停止している最中か停止に抵抗している場合に、どのスレッドが起動してもスレッドかプロセスをキャンセルできるようにして、スレッドは自らの意思で停止することができる。最後に**waitpid(2)**のような関数をを通してどのプロセスも子プロセスが終了するのを待つことができる。プロセスはどの子プロセスでも、もしくは指定した一つのスレッドが終了するのを待つことができる。プロセスはスリープ中以外の既に終了したプロセスを終了するのを待つ。  
このプロセス構造の所有権のシンプルな問題の実装における全てにおいて有名な試みである。もっとも明確な答えはプロセスはその子供の全てのプロセス構造を所有するべきであるということだ。これは我々が作成ししているwaitpidで作成しているプロセスツリーに反映され、よりシンプルな実装となっている。これを行う場合、事実にもとづいてプロセスは親のトラックを保持する必要性と、waitpidでスリープ中の親を通知する許可を対処する必要がある。さらに、現在のスレッド変数が常に通じていることが必要としないことは利便性において重要であり、したがって任意のプロセスIDをキャンセルか問い合わせ可能なプロセス構造の中に戻すことのいくつかの方法を必要とする。これらが我々が保持するプロセス構造体が最も参照カウントポインタである**Rc<KProc>**を全ての参照を所持しない**Weak<KProc>**という弱参照を通して使用することを全て許可する。これは我々にまだまだ提供されていてかつ完全な参照の取得のチェックなしで**Weak<T>**によるアクセスではないRustによる安全なアクセスをさせている間親としてのプロセス構造の所有を離させる。  
Rustを使用することの利点はこのスコープベースのデストラクタが幾分コードを単純にすることを許可された点にある。これらのデストラクタがいつでもスコープ外のオブジェクトコードをきれいにし、エラーを単純化してきれいにすることを認めた。例えば、一般的に新しいプロセスが何らかの理由で失敗した場合、全ての新しいプロセス構造を含めた一時的な変数が破棄され、エラーコードが変えされることは知ることができる。これは繰り返しアクションを複数の場所でクリーンアップする必要がなく、'goto error'ベースのクリーンアップシステムが必要ないことを意味する。  
  
